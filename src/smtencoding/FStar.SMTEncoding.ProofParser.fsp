%{
#light "off"
open FStar.SMTEncoding.RawProof
open FStar.Util
%}

%token LPAREN RPAREN
%token PROOF FUNCTION
%token <string> ID
%token <string> INT
%token TRUE FALSE
%token ANNOTATION PATTERN QID
%token PARAMETRIC
%token NOT AND OR IMPLIES IFF ITE
%token EQUAL EQUIV
%token LEQ LT GEQ GT PLUS TIMES MINUS DIVIDED MODULUS
%token FORALL EXISTS LAMBDA
%token LET
%token TERM BOOLEAN STRING INTEGER FUEL
%token ARBITRARY CONGRUENCE REFLEXIVITY SYMMETRY TRANSITIVITY REACHABILITY GENERALIZATION POSITIVE_NNF NEGATIVE_NNF REWRITING MODUS_PONENS MODUS_PONENS_EQUIV UNIT_RESOLUTION INSTANTIATION SKOLEMIZATION
%token PREMISE THEORY_LEMMA ARITHMETICS
%token ZERO_FUEL NEXT_FUEL
%token EOF

%start start
%type <raw_proof_section> start

%%

start:
    | LPAREN fundecls LPAREN PROOF proof RPAREN RPAREN EOF
        { (List.rev $2 , $5) }

fundecls:
    |
        { [] }
    | fundecls LPAREN FUNCTION ID LPAREN sorts RPAREN sort RPAREN
        { ($4 , List.rev $6 , $8) :: $1 }

proofs:
    |
        { [] }
    | proofs proof
        { $2 :: $1 }

proof:
    | ID
        { RawApplication (Uninterpreted $1 , []) }
    | ZERO_FUEL
        { RawFuel None }
    | LPAREN NEXT_FUEL proof RPAREN
        { RawFuel (Some $3)}
    | LPAREN operator proofs RPAREN
        { RawApplication ($2 , List.rev $3) }
    | LPAREN quantifier LPAREN bindings RPAREN proof RPAREN
        { RawBinding ($2 , List.rev $4 , $6) }
    | LPAREN LET LPAREN definitions RPAREN proof RPAREN
        { RawLet (List.rev $4 , $6) }
    | TRUE
        { RawBoolean true }
    | FALSE
        { RawBoolean false }
    | INT
        { RawInteger $1 }
    | LPAREN ANNOTATION proof annotations RPAREN
        { $3 }
    | LPAREN PREMISE proof RPAREN
        { RawPremise ($3) }
    | LPAREN UNIT_RESOLUTION proofs proof RPAREN
        { RawResolution (List.rev $3 , $4) }
    | LPAREN MODUS_PONENS proof proof proof RPAREN
        { RawResolution ([$3 ; $4] , $5) }
    | LPAREN MODUS_PONENS_EQUIV proof proof proof RPAREN
        { RawResolution ([$3 ; $4] , $5) }
    | LPAREN CONGRUENCE proofs proof RPAREN
        { RawCongruence (List.rev $3 , $4) }
    | LPAREN REFLEXIVITY proof RPAREN
        { RawCongruence ([] , $3) }
    | LPAREN SYMMETRY proof proof RPAREN
        { RawCongruence ([$3] , $4) }
    | LPAREN TRANSITIVITY proof proof proof RPAREN
        { RawCongruence ([$3 ; $4] , $5) }
    | LPAREN REACHABILITY proofs proof RPAREN
        { RawCongruence (List.rev $3 , $4) }
    | LPAREN REWRITING proof RPAREN
        { RawRewriting $3 }
    | LPAREN GENERALIZATION proof proof RPAREN
        { RawGeneralization ($3 , $4) }
    | LPAREN ARBITRARY proof proof RPAREN
        { RawGeneralization ($3 , $4) }
    | LPAREN LPAREN PARAMETRIC INSTANTIATION proofs RPAREN proof RPAREN
        { RawInstantiation (List.rev $5 , $7) }
    | LPAREN SKOLEMIZATION proof RPAREN
        { RawSkolemization $3 }
    | LPAREN POSITIVE_NNF proofs proof RPAREN
        { RawNnf (List.rev $3 , $4) }
    | LPAREN NEGATIVE_NNF proofs proof RPAREN
        { RawNnf (List.rev $3 , $4) }
    | LPAREN LPAREN PARAMETRIC THEORY_LEMMA ARITHMETICS ID proofs RPAREN proofs RPAREN
        { RawArithmetics (List.rev $7 , List.rev $9)}
    | LPAREN LPAREN PARAMETRIC THEORY_LEMMA ARITHMETICS RPAREN proofs RPAREN
        { RawArithmetics ([], List.rev $7)}

definitions:
    |
        { [] }
    | definitions LPAREN ID proof RPAREN
        { ($3 , $4) :: $1 }

bindings:
    |
        { [] }
    | bindings LPAREN ID sort RPAREN
        { ($3 , $4) :: $1 }

annotations:
    |
        { }
    | annotations PATTERN LPAREN proofs RPAREN
        { }
    | annotations QID ID
        { }

sorts:
    |
        { [] }
    | sorts sort
        { $2 :: $1 }

sort:
  | TERM
      { Term }
  | BOOLEAN
      { Boolean }
  | STRING
      { String }
  | INTEGER
      { Integer }
  | FUEL
      { Fuel }

operator:
  | AND
      { Conjunction }
  | OR
      { Disjunction }
  | NOT
      { Negation }
  | IMPLIES
      { Implication }
  | IFF
      { Biimplication }
  | ITE
      { Branch }
  | EQUAL
      { Equality }
  | EQUIV
      { Equivalence }
  | LEQ
      { LeqInequality }
  | LT
      { LtInequality }
  | GEQ
      { GeqInequality }
  | GT
      { GtInequality }
  | PLUS
      { Addition }
  | TIMES
      { Product }
  | MINUS
      { Opposite }
  | DIVIDED
      { Division }
  | MODULUS
      { Remainder }
  | ID
      { Uninterpreted $1 }

quantifier:
    | FORALL
        { Forall }
    | EXISTS
        { Exists }
    | LAMBDA
        { Lambda }