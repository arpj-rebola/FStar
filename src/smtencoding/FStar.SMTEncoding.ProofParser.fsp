%{
#light "off"
open FStar.SMTEncoding.RawProof
open FStar.Util
%}

%token LPAREN RPAREN
%token PROOF FUNCTION
%token <string> ID
%token <string> INT
%token TRUE FALSE
%token ANNOTATION PATTERN QID
%token PARAMETRIC
%token NOT AND OR IMPLIES
%token EQUAL EQUIV
%token LEQ LT GEQ GT PLUS TIMES MINUS
%token FORALL EXISTS LAMBDA
%token LET
%token TERM BOOLEAN STRING INTEGER FUEL
%token ARBITRARY CONGRUENCE REFLEXIVITY SYMMETRY TRANSITIVITY REACHABILITY GENERALIZATION POSITIVE_NNF NEGATIVE_NNF REWRITING MODUS_PONENS MODUS_PONENS_EQUIV UNIT_RESOLUTION INSTANTIATION SKOLEMIZATION
%token PREMISE THEORY_LEMMA ARITHMETICS
%token EOF

%start start
%type <raw_proof_section> start

%%

start:
    | LPAREN fundecls LPAREN PROOF proof RPAREN RPAREN EOF
        { (List.rev $2 , $5) }

fundecls:
    |
        { [] }
    | fundecls LPAREN FUNCTION ID LPAREN sorts RPAREN sort RPAREN
        { ($4 , List.rev $6 , $8) :: $1 }

proofs:
    |
        { [] }
    | proofs proof
        { $2 :: $1 }

proof:
    | ID
        { RawApplication (Uninterpreted $1 , []) }
    | LPAREN operator proofs RPAREN
        { RawApplication ($2 , List.rev $3) }
    | LPAREN quantifier LPAREN bindings RPAREN proof RPAREN
        { RawBinding ($2 , List.rev $4 , $6) }
    | LPAREN LET LPAREN definitions RPAREN proof RPAREN
        { RawLet (List.rev $4 , $6) }
    | TRUE
        { RawBoolean true }
    | FALSE
        { RawBoolean false }
    | INT
        { RawInteger $1 }
    | LPAREN ANNOTATION proof annotations RPAREN
        { $3 }
    | LPAREN PREMISE proof RPAREN
        { RawInference (RawPremise , [proof]) }
    | LPAREN UNIT_RESOLUTION proofs proof RPAREN
        { RawInference (RawResolution , $4 :: (List.rev $3)) }
    | LPAREN MODUS_PONENS proof proof proof RPAREN
        { RawInference (RawResolution , [$5 ; $3 ; $4] }
    | LPAREN MODUS_PONENS_EQUIV proof proof proof RPAREN
        { RawInference (RawResolution , [$5 ; $3 ; $4] }
    | LPAREN CONGRUENCE proofs proof RPAREN
        { RawInference (RawCongruence , $4 :: (List.rev $3)) }
    | LPAREN REFLEXIVITY proof RPAREN
        { RawInference (RawCongruence , [$3]) }
    | LPAREN SYMMETRY proof proof RPAREN
        { RawInference (RawCongruence , [$4 ; $3]) }
    | LPAREN TRANSITIVITY proof proof proof RPAREN
        { RawInference (RawCongruence , [$5 ; $3 ; $4]) }
    | LPAREN REACHABILITY proofs proof RPAREN
        { RawInference (RawCongruence , $4 :: (List.rev $3)) }
    | LPAREN REWRITING proof RPAREN
        { RawInference (RawRewrite , [$3]) }
    | LPAREN ARBITRARY proof proof RPAREN
        { RawInference (RawArbitrary , [$4 ; $3]) }
    | LPAREN LPAREN PARAMETRIC INSTANTIATION proofs RPAREN proof RPAREN
        { RawInference (RawInstantiation (List.rev $5) , [$7]) }
    | LPAREN SKOLEMIZATION proof RPAREN
        { RawInference (RawSkolemization , [$3]) }
    | LPAREN POSITIVE_NNF proofs RPAREN
        { RawInference (RawNnf , [List.rev $3]) }
    | LPAREN NEGATIVE_NNF proofs RPAREN
        { RawInference (RawNnf , [List.rev $3]) }
    | LPAREN LPAREN PARAMETRIC THEORY_LEMMA ARITHMETICS ID proofs RPAREN proofs RPAREN
        { RawInference (RawArithmetics ($6 , List.rev $7) , List.rev $9) }
    | LPAREN LPAREN PARAMETRIC THEORY_LEMMA ARITHMETICS RPAREN proofs RPAREN
        { RawInference (RawArithmetics ("" , List.rev $6) , List.rev $8) }

definitions:
    |
        { [] }
    | definitions LPAREN ID proof RPAREN
        { ($3 , $4) :: $1 }

bindings:
    |
        { [] }
    | bindings LPAREN ID sort RPAREN
        { ($3 , $4) :: $1 }

annotations:
    |
        { }
    | annotations PATTERN LPAREN proofs RPAREN
        { }
    | annotations QID ID
        { }

sorts:
    |
        { [] }
    | sorts sort
        { $2 :: $1 }

sort:
  | TERM
      { Term }
  | BOOLEAN
      { Boolean }
  | STRING
      { String }
  | INTEGER
      { Integer }
  | FUEL
      { Fuel }

operator:
  | AND
      { Conjunction }
  | OR
      { Disjunction }
  | NOT
      { Negation }
  | IMPLIES
      { Implication }
  | EQUAL
      { Equality }
  | EQUIV
      { Equivalence }
  | LEQ
      { LeqInequality }
  | LT
      { LtInequality }
  | GEQ
      { GeqInequality }
  | GT
      { GtInequality }
  | PLUS
      { Addition }
  | TIMES
      { Product }
  | MINUS
      { Opposite }
  | ID
      { Uninterpreted $1 }

quantifier:
    | FORALL
        { Forall }
    | EXISTS
        { Exists }
    | LAMBDA
        { Lambda }